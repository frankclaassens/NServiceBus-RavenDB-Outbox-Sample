using System;
using System.Diagnostics;
using System.Linq;
using System.Transactions;
using NServiceBus;
using NServiceBus.RavenDB.Persistence;
using NServiceBus.UnitOfWork;
using Raven.Client;

namespace Common
{
	public class UnitOfWork : IManageUnitsOfWork
	{
		private readonly ISessionProvider _sessionProvider;

		private readonly IBus _bus;

		private Stopwatch _sw;

		public UnitOfWork(IBus bus, ISessionProvider sessionProvider)
		{
			_bus = bus;
			_sessionProvider = sessionProvider;			
		}

		public void Begin()
		{
			Console.WriteLine("Begin unit of work.");
			_sw = Stopwatch.StartNew();
		}

		public void End(Exception internalException = null)
		{
			ProcessEnd(internalException);

			_sw.Stop();
			Console.WriteLine($"End unit of work - {_sw.ElapsedMilliseconds}ms.");
		}

		private void ProcessEnd(Exception internalException = null)
		{
			if (_bus.CurrentMessageContext == null)
			{
				return;
			}

			string enclosedMessageTypes = _bus.EnclosedMessageTypes();

			// If there are no enclosed message types then we assume that this is an internal NSB message that is being processed and as such doesn't
			// need our custom unit of work processing.
			if (enclosedMessageTypes == null)
			{
				return;
			}

			Exception unitOfWorkException = internalException;

			if (unitOfWorkException == null)
			{
				// If there are any issues with saving changes then we also want to class this as a unit of work exception.
				try
				{
					Console.WriteLine($"Total Requests = {_sessionProvider.Session.Advanced.NumberOfRequests}");

					if (Transaction.Current == null)
					{
						throw new TransactionException("Transaction has been illegally set to null");
					}

					// Check for whether the transaction has been aborted.  This gives a better error message than the one generated by raven.
					if (Transaction.Current.TransactionInformation.Status == TransactionStatus.Aborted)
					{
						string message =
							$"The transaction has been aborted after {DateTime.Now - Transaction.Current.TransactionInformation.CreationTime}.  This could be due to the handler taking too long to execute.";
						throw new TransactionException(message);
					}

					ValidateRequestCount(enclosedMessageTypes);
					_sessionProvider.Session.SaveChanges();
				}
				catch (Exception e)
				{
					unitOfWorkException = e;
				}
			}

			string errorMessage = null;

			if (unitOfWorkException != null)
			{
				if (!enclosedMessageTypes.Contains(".RecalculateOfferings,"))
				{
					errorMessage = unitOfWorkException.Message;
					Console.WriteLine($"Unit of work failed for enclosed message types {enclosedMessageTypes}.", unitOfWorkException);
				}
				else
				{
					unitOfWorkException = null;
					internalException = null;
				}
			}

			ProcessManagement(errorMessage);

			// If an internal exception has not occurred but during process end, an exception has been raised then we need to throw it
			// to ensure the unit of work fails.
			if (internalException == null && unitOfWorkException != null)
			{
				throw unitOfWorkException;
			}
		}

		/// <summary>
		/// If raven reaches the maximum number of session requests during the commitment of a transaction then it locks out the files
		/// referenced within that session for a period of time.  This method proactively guards against this scenario.
		/// </summary>
		private void ValidateRequestCount(string enclosedMessageTypes)
		{
			var currentNumberOfRequests = _sessionProvider.Session.Advanced.NumberOfRequests;
			var maxRavenRequests = _sessionProvider.Session.Advanced.MaxNumberOfRequestsPerSession;

			if (currentNumberOfRequests > (maxRavenRequests - 2))
			{
				Func<string> messageFunc =
					() =>
							$"The message type {enclosedMessageTypes} made {currentNumberOfRequests} requests which is close to exceeding the maximum number of requests prior to saving ({maxRavenRequests}).";
				Console.WriteLine((messageFunc));
			}
		}

		private void ProcessManagement(string errorMessage)
		{
			Guid? processId = _bus.GetProcessId();

			if (!processId.HasValue)
			{
				return;
			}

			var fullProcessMode = _bus.FullProcessMode();

			try
			{
				if (errorMessage == null)
				{
					ProcessManagementSuccess(processId.Value, fullProcessMode);
					return;
				}

				ProcessManagementError(processId.Value, fullProcessMode, errorMessage);
			}
			catch (Exception e)
			{
				// If any error occurs during the setting of error task status then we want to suppress it but log it.  This is to prevent the original exception being swallowed up.
				Func<string> message = () => $"Error occurred updating process status for message id {_bus.CurrentMessageContext.Id}.";
				Console.WriteLine((message));
			}
		}

		private void ProcessManagementSuccess(Guid processId, bool fullProcessMode)
		{
			if (fullProcessMode)
			{
				var firstInProcess = _bus.FirstMessageInProcess();
				int outgoingCount = _bus.GetOutgoingTransportMessagesCount();
				AddProcessStatus(processId, firstInProcess, outgoingCount);
			}
			else
			{
				var publishedEvents = _bus.GetPublishedEvents();
				AddProcessEvent(processId, publishedEvents);
			}
		}

		private void ProcessManagementError(Guid processId, bool fullProcessMode, string errorMessage)
		{
			// As an exception has been thrown we need to suppress the trasaction when writing to the database
			// else it will be rolled back with everything else.
			using (TransactionScope scope = new TransactionScope(TransactionScopeOption.Suppress))
			{
				if (fullProcessMode)
				{
					AddErrorProcessStatus(processId, errorMessage);
				}
				else
				{
					AddErrorProcessEvent(processId, errorMessage);
				}

				scope.Complete();
			}
		}

		private void AddProcessEvent(Guid processId, string[] events)
		{
			if (!events.Any())
			{
				return;
			}

			using (IDocumentSession newSession = _sessionProvider.Session.Advanced.DocumentStore.OpenSession())
			{
				ProcessHelpers.RegisterProcessEvent(processId, events, newSession);
				newSession.SaveChanges();
			}
		}

		private void AddProcessStatus(Guid processId, bool firstInProcess, int outgoingCount)
		{
			int processDelta = firstInProcess ? 0 : -1;
			processDelta += outgoingCount;

			if (!firstInProcess && processDelta == 0)
			{
				return;
			}

			using (IDocumentSession newSession = _sessionProvider.Session.Advanced.DocumentStore.OpenSession())
			{
				ProcessHelpers.RegisterProcessStatus(processId, processDelta, newSession);
				newSession.SaveChanges();
			}
		}

		private void AddErrorProcessEvent(Guid processId, string errorMessage)
		{
			using (IDocumentSession newSession = _sessionProvider.Session.Advanced.DocumentStore.OpenSession())
			{
				ProcessHelpers.RegisterErrorProcessEvent(processId, errorMessage, _bus, newSession);
				newSession.SaveChanges();
			}
		}

		private void AddErrorProcessStatus(Guid processId, string errorMessage)
		{
			using (IDocumentSession newSession = _sessionProvider.Session.Advanced.DocumentStore.OpenSession())
			{
				ProcessHelpers.RegisterErrorProcessStatus(processId, errorMessage, _bus, newSession);
				newSession.SaveChanges();
			}
		}
	}
}
